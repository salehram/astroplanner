{% extends "base.html" %}
{% block content %}

<style>
  .subexp-input {
    width: 90px !important;
    min-width: 90px !important;
  }
  .minutes-input {
    width: 90px !important;
    min-width: 90px !important;
  }

  /* Allow header text in the plan table to wrap to 2 lines */
  #plan-table th {
    white-space: normal;
    vertical-align: middle;
  }
</style>

<!-- HEADER -->
<div class="d-flex justify-content-between align-items-center mb-3">
  <div>
    <h1 class="h3 mb-0">{{ target.name }}</h1>
    <div class="text-light small">
      {{ target.catalog_id or "No catalog ID" }} •
      {{ target.target_type or "Type N/A" }} •
      RA {{ "%.3f"|format(target.ra_hours) }}h,
      Dec {{ "%.2f"|format(target.dec_deg) }}°
      {% if target_created_local %}
        • <span class="text-warning">
            Created {{ target_created_local.strftime("%Y-%m-%d %H:%M:%S") }}
          </span>
      {% endif %}
    </div>
  </div>
  <div class="d-flex gap-2">
    <a href="{{ url_for('edit_target', target_id=target.id) }}"
       class="btn btn-outline-light btn-sm">
      <i class="bi bi-pencil me-1"></i>Edit
    </a>
    <a href="{{ url_for('target_settings', target_id=target.id) }}"
       class="btn btn-outline-info btn-sm">
      <i class="bi bi-gear me-1"></i>Settings
    </a>
    <form method="post"
          action="{{ url_for('delete_target', target_id=target.id) }}"
          onsubmit="return confirm('Delete target {{ target.name }} and all its data?');">
      <button class="btn btn-outline-danger btn-sm" type="submit">
        <i class="bi bi-trash me-1"></i>Delete
      </button>
    </form>
  </div>
</div>

<!-- ROW 1: PLAN & PALETTE (FULL WIDTH) -->
<div class="row g-4 mb-4">
  <div class="col-12">
    <div class="card bg-secondary text-light">
      <div class="card-header d-flex justify-content-between align-items-center">
        <span>Plan & Palette</span>
        <form method="post" action="{{ url_for('new_plan', target_id=target.id) }}"
              class="d-flex gap-2">
          <select name="palette" class="form-select form-select-sm">
            {% for palette in palettes %}
              <option value="{{ palette.name }}" {% if palette.name==target.preferred_palette %}selected{% endif %}>
                {{ palette.display_name }}
              </option>
            {% endfor %}
          </select>
          <button class="btn btn-sm btn-outline-light" type="submit">
            <i class="bi bi-plus-circle me-1"></i>New Plan
          </button>
        </form>
      </div>

      <div class="card-body">
        {% if plan_data %}

          <p class="mb-1"><strong>Palette:</strong> {{ plan_data.palette }}</p>
          <p class="mb-2"><strong>Dominant Channel:</strong> {{ plan_data.dominant_channel }}</p>

          <form method="post" action="{{ url_for('update_plan', target_id=target.id) }}" id="plan-form">

            <div class="row mb-3">
              <div class="col-md-4 mb-2">
                <label class="form-label">Total Planned Time</label>
                <div class="input-group input-group-sm">
                  <input id="total_planned_minutes" class="form-control"
                         type="number" step="0.1" min="0"
                         name="total_planned_minutes"
                         value="{{ plan_data.total_planned_minutes }}"
                         placeholder="Minutes">
                  <span class="input-group-text">min</span>
                </div>
                <input id="total_planned_hms" class="form-control form-control-sm mt-1"
                       type="text" placeholder="H:M:S format (e.g. 6:00:00)"
                       title="Enter time in H:M:S format">
              </div>

              <div class="col-md-4 mb-2">
                <label class="form-label">Fallback Sub-exposure (s)</label>
                <input id="plan_sub_exposure" class="form-control form-control-sm"
                       type="number" min="1" step="1" value="300">
              </div>
            </div>

            <!-- MAIN WIDE TABLE -->
            <div class="table-responsive" style="padding-bottom: 12px;">
              <table id="plan-table"
                     class="table table-sm table-dark align-middle mb-0"
                     data-tonight-minutes="{{ window_info.total_minutes or 0 }}">

                <thead>
                  <tr>
                    <th>Channel</th>
                    <th>Label</th>
                    <th>Planned (mins)</th>
                    <th>Planned (h:m:s)</th>
                    <th>Sub (s)</th>
                    <th>Planned Frames</th>
                    <th>Completed Time</th>
                    <th>Done Frames</th>
                    <th>Remaining Frames</th>
                    <th>Remaining Time</th>
                    <th>Remaining (h:m:s)</th>
                    <th>Status</th>
                    <th style="width: 35px;"></th>
                  </tr>
                </thead>

                <tbody>
                  {% for ch in plan_data.channels %}
                    {% set done = progress_minutes.get(ch.name, 0) %}
                    {% set done_sec = progress_seconds.get(ch.name, 0) %}
                    <tr class="plan-row">
                      <td>{{ ch.name }}</td>
                      <td>{{ ch.label }}</td>

                      <!-- Planned minutes (editable) -->
                      <td>
                        <input class="form-control form-control-sm channel-minutes minutes-input"
                              type="number" step="0.1" min="0"
                              name="ch_{{ ch.name }}_minutes"
                              value="{{ ch.planned_minutes }}"
                              title="Minutes">
                      </td>

                      <!-- Planned H:M:S (editable) -->
                      <td>
                        <input class="form-control form-control-sm channel-hms hms-input"
                              type="text" placeholder="H:M:S"
                              title="H:M:S format (e.g. 3:00:00)">
                      </td>

                      <!-- Sub-exposure -->
                      <td>
                        <input class="form-control form-control-sm channel-subexp subexp-input"
                              type="number" step="0.001" min="0.001"
                              name="ch_{{ ch.name }}_subexp"
                              value="{{ ch.sub_exposure_seconds or 300 }}">
                      </td>

                      <!-- Planned frames (editable – drives minutes if you change it) -->
                      <td>
                        <input class="form-control form-control-sm planned-frames-input"
                              type="number" step="1" min="0"
                              value="">
                      </td>

                      <!-- Completed minutes -->
                      <td class="completed-minutes"
                          data-done-seconds="{{ done_sec|default(0) }}">
                        {{ "%.1f"|format(done) }}
                      </td>

                      <!-- Done / remaining -->
                      <td class="done-frames">-</td>
                      <td class="remaining-frames fw-bold">-</td>
                      <td class="remaining-minutes fw-bold">-</td>
                      <td class="remaining-hms fw-bold">-</td>
                      <td class="status-badge"></td>
                      <td>
                        <button type="button" class="btn btn-sm btn-outline-danger remove-filter-btn" 
                                data-channel="{{ ch.name }}" title="Remove this filter">
                          <i class="bi bi-trash"></i>
                        </button>
                      </td>
                    </tr>
                  {% endfor %}
                </tbody>

              </table>
            </div>

            <!-- Add Custom Filter Interface -->
            <div class="mb-3">
              <!-- Toggle Button -->
              <button class="btn btn-warning btn-sm mb-2" type="button" 
                      data-bs-toggle="collapse" data-bs-target="#customFilterCollapse" 
                      aria-expanded="false" aria-controls="customFilterCollapse"
                      id="customFilterToggleBtn">
                <i class="bi bi-plus-circle me-1"></i>Add Custom Filter
                <i class="bi bi-chevron-down ms-1" id="toggleChevron"></i>
              </button>
              
              <!-- Collapsible Content -->
              <div class="collapse" id="customFilterCollapse">
                <div class="card bg-dark border-warning">
                  <div class="card-body">
                    <div class="row g-2">
                      <div class="col-md-3">
                        <label class="form-label small fw-bold text-light">Channel <span class="text-danger">*</span></label>
                        <input class="form-control form-control-sm" id="custom_channel_name" 
                               placeholder="e.g., O_HDR_4, H_NB, R_LP" maxlength="16">
                      </div>
                      <div class="col-md-3">
                        <label class="form-label small fw-bold text-light">Label/Description</label>
                        <input class="form-control form-control-sm" id="custom_channel_label" 
                               placeholder="e.g., OIII HDR #4, H-Alpha Narrowband">
                      </div>
                      <div class="col-md-2">
                        <label class="form-label small fw-bold text-light">Maps to Filter <span class="text-danger">*</span></label>
                        <select class="form-control form-control-sm" id="custom_channel_nina_filter">
                          <option value="">Select...</option>
                          <option value="H">H (H-Alpha)</option>
                          <option value="O">O (OIII)</option>
                          <option value="S">S (SII)</option>
                          <option value="L">L (Luminance)</option>
                          <option value="R">R (Red)</option>
                          <option value="G">G (Green)</option>
                          <option value="B">B (Blue)</option>
                          <option value="LP">LP (Light Pollution)</option>
                        </select>
                      </div>
                      <div class="col-md-2">
                        <label class="form-label small fw-bold text-light">Weight</label>
                        <input class="form-control form-control-sm" id="custom_channel_weight" 
                               type="number" min="0" step="0.1" value="1.0">
                      </div>
                      <div class="col-md-2 d-flex align-items-end">
                        <button type="button" class="btn btn-success btn-sm w-100" id="add_custom_filter_btn">
                          <i class="bi bi-plus-circle me-1"></i>Add Filter
                        </button>
                      </div>
                    </div>
                    
                    <div class="row g-2 mt-1">
                      <div class="col-md-3">
                        <label class="form-label small fw-bold text-light">Planned (mins)</label>
                        <input class="form-control form-control-sm custom-calc-input" id="custom_channel_minutes" 
                               type="number" min="0" step="0.1" placeholder="Auto calculated">
                      </div>
                      <div class="col-md-3">
                        <label class="form-label small fw-bold text-light">Sub Exposure (s)</label>
                        <input class="form-control form-control-sm custom-calc-input" id="custom_channel_exposure" 
                               type="number" min="0.001" step="0.001" placeholder="e.g., 0.5, 5.5, 30">
                      </div>
                      <div class="col-md-3">
                        <label class="form-label small fw-bold text-light">Frames Count</label>
                        <input class="form-control form-control-sm custom-calc-input" id="custom_channel_frames" 
                               type="number" min="1" step="1" placeholder="Auto calculated">
                      </div>
                      <div class="col-md-3 d-flex align-items-end">
                        <div class="alert alert-info alert-sm mb-0 py-1 px-2 w-100">
                          <small><i class="bi bi-info-circle me-1"></i>Fill any 2 fields - 3rd auto-calculates</small>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Hidden inputs for removed and custom filters -->
            <div id="removed_filters_container"></div>
            <div id="custom_filters_container"></div>

            <button class="btn btn-outline-light btn-sm mt-3" type="submit">
              <i class="bi bi-floppy me-1"></i>Save Plan
            </button>

            <button class="btn btn-outline-info btn-sm mt-3"
                    formaction="{{ url_for('export_nina_sequence', target_id=target.id) }}"
                    formmethod="post">
              <i class="bi bi-download me-1"></i>Export NINA Sequence (remaining subs)
            </button>

          </form>
        {% else %}
          <p>No plan yet. Create one above.</p>
        {% endif %}
      </div>
    </div>
  </div>
</div>

<!-- ROW 2: TONIGHT'S WINDOW (LEFT) + RIGHT COLUMN STACK (PROGRESS + NOTES + PIXINSIGHT) -->
<div class="row g-4 mb-4">
  <!-- TONIGHT -->
  <div class="col-lg-6">
    <div class="card bg-secondary text-light h-100">
      <div class="card-header d-flex justify-content-between align-items-center">
        <span>Tonight's Window</span>
        <small class="text-muted">
          Local TZ:
          <span title="Taken from OBSERVER_TZ environment variable">
            {{ window_info.timezone_name or "Unknown" }}
          </span>
        </small>
      </div>

      <div class="card-body">
        {% if window_info.deps_available %}
          <p class="mb-1">
            <strong>Sunset (local):</strong> {{ window_info.sunset_local }}
            <span class="text-warning small">[UTC: {{ window_info.sunset_utc }}]</span>
          </p>

          <p class="mb-1">
            <strong>Dark Start (local):</strong> {{ window_info.dark_start_local }}
            <span class="text-warning small">[UTC: {{ window_info.dark_start_utc }}]</span>
          </p>

          <p class="mb-1">
            <strong>Dark End (local):</strong> {{ window_info.dark_end_local }}
            <span class="text-warning small">[UTC: {{ window_info.dark_end_utc }}]</span>
          </p>

          <p class="mb-1">
            <strong>Meridian Transit (local):</strong> {{ window_info.meridian_local }}
            <span class="text-warning small">[UTC: {{ window_info.meridian_utc }}]</span>
          </p>

          <hr class="my-2">

          <p class="mb-1">
            <strong>Effective Start (local):</strong> {{ window_info.start_time_local }}
            <span class="text-warning small">[UTC: {{ window_info.start_time_utc }}]</span>
          </p>

          <p class="mb-1">
            <strong>Effective End (local):</strong> {{ window_info.end_time_local }}
            <span class="text-warning small">[UTC: {{ window_info.end_time_utc }}]</span>
          </p>

          <p class="mb-1">
            <strong>Total Window:</strong>
            {% if window_info.total_minutes is not none %}
              {{ window_info.total_minutes|format_hms_from_minutes }} ({{ window_info.total_minutes }} minutes)
            {% else %}
              N/A
            {% endif %}
          </p>

          <p class="mb-1 small text-muted">
            Altitude threshold used: ≥ {{ window_info.min_altitude_deg }}° •
            Mid-window altitude:
            {% if window_info.midpoint_altitude_deg is not none %}
              {{ window_info.midpoint_altitude_deg }}°
            {% else %}
              N/A
            {% endif %}
          </p>

          <!-- Why this window is this long -->
          <div class="mt-2 small text-muted">
            <strong>Why is this window {{ window_info.total_minutes }} min?</strong><br>
            • Nautical night (local): {{ window_info.dark_start_local }} → {{ window_info.dark_end_local }}<br>
            • Pack-up time (local clock): {{ target.packup_time_local or "none (using full dark)" }}<br>
            • Base dark+packup window:
              {{ window_info.raw_start_local }} → {{ window_info.raw_end_local }}
              ({{ window_info.raw_total_minutes }} min)<br>
            • Applying altitude ≥ {{ window_info.min_altitude_deg }}° gives:
              {{ window_info.start_time_local }} → {{ window_info.end_time_local }}
              ({{ window_info.total_minutes }} min).
          </div>

          <!-- Altitude chart -->
          {% if window_info.altitude_profile and window_info.altitude_profile|length > 0 %}
            <hr class="my-3">
            <h6 class="small text-uppercase text-muted mb-1">Altitude over night</h6>
            <canvas id="altitudeChart" height="160"></canvas>
          {% endif %}

        {% else %}
          <p>{{ window_info.note }}</p>
          <p>Install astropy + astroplan for full functionality.</p>
        {% endif %}
      </div>
    </div>
  </div>

  <!-- RIGHT COLUMN STACK: PROGRESS + NOTES + PIXINSIGHT -->
  <div class="col-lg-6 d-flex flex-column gap-4">
    <!-- ADD IMAGING PROGRESS -->
    <div class="card bg-secondary text-light">
      <div class="card-header">Add Imaging Progress</div>
      <div class="card-body">
        <form method="post" action="{{ url_for('add_progress', target_id=target.id) }}">
          <div class="row mb-2">
            <div class="col-md-6">
              <label class="form-label">Date</label>
              <input class="form-control" name="imaging_date" type="date" 
                     value="{{ datetime.now().strftime('%Y-%m-%d') }}" required>
            </div>
          </div>
          
          <div class="row">
            <div class="col-md-4 mb-2">
              <label class="form-label">Filter</label>
              {% if plan_data and plan_data.channels %}
                <select class="form-control" name="channel" id="progress_channel" required>
                  <option value="">Select a filter...</option>
                  {% for ch in plan_data.channels %}
                    <option value="{{ ch.name }}" data-exposure="{{ ch.sub_exposure_seconds or 300 }}">{{ ch.name }} - {{ ch.label }}</option>
                  {% endfor %}
                </select>
              {% else %}
                <input class="form-control" name="channel"
                       placeholder="H, O, S, L, R, G, B" required>
                <div class="form-text text-warning">
                  <i class="bi bi-exclamation-triangle me-1"></i>No plan found - using manual input
                </div>
              {% endif %}
            </div>

            <div class="col-md-4 mb-2">
              <label class="form-label">Sub Exposure (s)</label>
              <input class="form-control" name="sub_exposure_seconds" id="progress_exposure"
                     type="number" value="300" required {% if plan_data and plan_data.channels %}readonly{% endif %}>
              {% if plan_data and plan_data.channels %}
                <div class="form-text text-info">
                  <i class="bi bi-info-circle me-1"></i>Auto-filled from plan
                </div>
              {% endif %}
            </div>

            <div class="col-md-4 mb-2">
              <label class="form-label">Sub Count</label>
              <input class="form-control" name="sub_count"
                     type="number" value="10" required>
            </div>
          </div>

          <div class="mb-2">
            <label class="form-label">Notes (optional)</label>
            <input class="form-control" name="notes">
          </div>

          <button class="btn btn-primary btn-sm" type="submit">
            <i class="bi bi-plus-circle me-1"></i>Add Progress
          </button>
        </form>
      </div>
    </div>

    <!-- NOTES -->
    <div class="card bg-secondary text-light">
      <div class="card-header">Notes</div>
      <div class="card-body">
        {% if target.notes %}
          <pre class="mb-0" style="white-space: pre-wrap;">{{ target.notes }}</pre>
        {% else %}
          <p class="text-muted mb-0">No notes yet.</p>
        {% endif %}
      </div>
    </div>

    <!-- PIXINSIGHT WORKFLOW -->
    <div class="card bg-secondary text-light">
      <div class="card-header">PixInsight Workflow</div>
      <div class="card-body">
        {% if target.pixinsight_workflow %}
          <pre class="mb-0" style="white-space: pre-wrap;">{{ target.pixinsight_workflow }}</pre>
        {% else %}
          <p class="text-muted mb-0">No workflow documented yet.</p>
        {% endif %}
      </div>
    </div>
  </div>
</div>

<!-- ROW: FINAL IMAGE -->
<div class="row g-4">
  <div class="col-12">
    <div class="card bg-secondary text-light">
      <div class="card-header">Final Image</div>

      <div class="card-body">
        {% if target.final_image_filename %}
          <div class="mb-2">
            <img src="{{ url_for('uploaded_file', filename=target.final_image_filename) }}"
                 class="img-fluid rounded border border-light">
          </div>
          <p class="text-muted small">Saved as {{ target.final_image_filename }}</p>
        {% else %}
          <p class="text-muted">No final image uploaded yet.</p>
        {% endif %}

        <hr>

        <form method="post" enctype="multipart/form-data"
              action="{{ url_for('upload_final_image', target_id=target.id) }}">
          <div class="mb-2">
            <label class="form-label">Upload final processed image</label>
            <input class="form-control" type="file" name="final_image" accept="image/*">
          </div>
          <button class="btn btn-outline-light btn-sm" type="submit">
            <i class="bi bi-upload me-1"></i>Upload / Replace
          </button>
        </form>
      </div>

    <!-- TARGET IMAGING PROGRESS -->
    {% if target.sessions %}
    <div class="card bg-secondary text-light">
      <div class="card-header d-flex justify-content-between align-items-center">
        <span>Imaging Progress</span>
        <a href="{{ url_for('imaging_logs') }}" class="btn btn-sm btn-outline-light">
          <i class="bi bi-journal-text me-1"></i>View All Logs
        </a>
      </div>
      <div class="card-body">
        {% set sessions_by_date = {} %}
        {% for session in target.sessions %}
          {% if session.date not in sessions_by_date %}
            {% set _ = sessions_by_date.update({session.date: []}) %}
          {% endif %}
          {% set _ = sessions_by_date[session.date].append(session) %}
        {% endfor %}
        
        {% for date, sessions in sessions_by_date.items() | reverse %}
          <div class="border rounded p-3 mb-3 bg-dark">
            <div class="d-flex justify-content-between align-items-center mb-2">
              <h6 class="text-info mb-0">
                <i class="bi bi-calendar-date me-1"></i>
                {{ date.strftime('%A, %B %d, %Y') }}
              </h6>
              <span class="badge bg-primary">{{ sessions|length }} session(s)</span>
            </div>
            
            {% for session in sessions %}
              <div class="d-flex justify-content-between align-items-center py-2 {% if not loop.last %}border-bottom border-secondary{% endif %}">
                <div>
                  <span class="badge bg-warning text-dark me-2">{{ session.channel }}</span>
                  <span class="text-light">
                    {{ session.sub_count }}x {{ session.sub_exposure_seconds }}s
                    <small class="text-muted">
                      ({{ ((session.sub_count * session.sub_exposure_seconds) / 60) | round(1) }}m)
                    </small>
                  </span>
                </div>
                <div class="text-end">
                  {% if session.notes %}
                    <small class="text-light d-block" title="{{ session.notes }}">
                      <i class="bi bi-chat-quote me-1"></i>{{ session.notes[:30] }}{% if session.notes|length > 30 %}...{% endif %}
                    </small>
                  {% endif %}
                </div>
              </div>
            {% endfor %}
            
            <!-- Daily summary for this target -->
            {% set daily_total = [] %}
            {% for session in sessions %}
              {% set _ = daily_total.append((session.sub_count * session.sub_exposure_seconds) / 60) %}
            {% endfor %}
            
            <div class="mt-2 pt-2 border-top border-secondary">
              <small class="text-success">
                <i class="bi bi-clock me-1"></i>
                <strong>Day Total: {{ daily_total | sum | round(1) }} minutes</strong>
                {% if daily_total | sum >= 60 %}
                  <span class="text-muted">({{ (daily_total | sum / 60) | round(2) }} hours)</span>
                {% endif %}
              </small>
            </div>
          </div>
        {% endfor %}
        
        <!-- Overall target progress summary -->
        {% set total_target_minutes = [] %}
        {% for session in target.sessions %}
          {% set _ = total_target_minutes.append((session.sub_count * session.sub_exposure_seconds) / 60) %}
        {% endfor %}
        
        <div class="mt-3 pt-3 border-top border-light">
          <div class="row text-center">
            <div class="col-md-4">
              <div class="text-primary">
                <strong>{{ target.sessions|length }}</strong>
                <small class="d-block text-muted">Total Sessions</small>
              </div>
            </div>
            <div class="col-md-4">
              <div class="text-success">
                <strong>{{ (target.sessions | map(attribute='date') | unique | list) | length }}</strong>
                <small class="d-block text-muted">Imaging Days</small>
              </div>
            </div>
            <div class="col-md-4">
              <div class="text-warning">
                <strong>{{ total_target_minutes | sum | round(1) }}m</strong>
                <small class="d-block text-muted">Total Time</small>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    {% endif %}

    </div>
  </div>
</div>

<!-- Chart.js for altitude plot -->
<script src="{{ url_for('static', filename='js/chart.umd.js') }}"></script>

<!-- JS: Progress calculations + status badges + altitude chart -->
<script>
document.addEventListener("DOMContentLoaded", function () {
  const globalExpInput = document.getElementById("plan_sub_exposure");
  const planTable = document.getElementById("plan-table");
  const rows = document.querySelectorAll("tr.plan-row");
  
  // Check if we need to refresh (coming from settings update)
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.get('_refresh') === 'true') {
    // Remove the parameter from URL to clean it up
    window.history.replaceState({}, document.title, window.location.pathname);
    // Simple page reload to get fresh data
    window.location.reload();
  }

  const tonightWindowMinutes = planTable
    ? parseFloat(planTable.dataset.tonightMinutes || "0") || 0
    : 0;
    
  function refreshWindowData() {
    // Get updated window information from server
    fetch(`/api/target/{{ target.id }}/window`)
      .then(response => response.json())
      .then(data => {
        if (data.deps_available) {
          // Update window information display
          updateWindowDisplay(data);
          // Refresh altitude chart
          updateAltitudeChart(data);
        }
      })
      .catch(error => {
        console.error('Error refreshing window data:', error);
      });
  }
  
  function updateWindowDisplay(windowInfo) {
    // Update various text elements with new window info
    const elements = {
      'sunset-local': windowInfo.sunset_local,
      'dark-start-local': windowInfo.dark_start_local,
      'dark-end-local': windowInfo.dark_end_local,
      'meridian-local': windowInfo.meridian_local,
      'effective-start-local': windowInfo.start_time_local,
      'effective-end-local': windowInfo.end_time_local,
      'total-window': `${formatHMS(windowInfo.total_minutes * 60)} (${windowInfo.total_minutes} minutes)`,
      'min-altitude': windowInfo.min_altitude_deg + '°',
      'mid-altitude': (windowInfo.midpoint_altitude_deg !== null ? windowInfo.midpoint_altitude_deg + '°' : 'N/A')
    };
    
    // Update elements that exist
    Object.entries(elements).forEach(([id, value]) => {
      const element = document.getElementById(id);
      if (element) {
        element.textContent = value;
      }
    });
  }
  
  let altitudeChart; // Store chart instance globally

  function formatHMS(totalSeconds) {
    totalSeconds = Math.max(0, Math.floor(totalSeconds));
    const h = Math.floor(totalSeconds / 3600);
    const m = Math.floor((totalSeconds % 3600) / 60);
    const s = totalSeconds % 60;
    return String(h).padStart(2,"0") + ":" +
           String(m).padStart(2,"0") + ":" +
           String(s).padStart(2,"0");
  }

  function recalcFrames() {
    console.log('recalcFrames called');
    if (!planTable) {
      console.log('No planTable found');
      return;
    }

    // Get rows dynamically instead of using cached variable
    const currentRows = document.querySelectorAll("#plan-table tr.plan-row");
    console.log('Current rows found:', currentRows.length);

    const globalExp = globalExpInput
      ? parseFloat(globalExpInput.value)
      : NaN;

    console.log('Global exposure:', globalExp);

    currentRows.forEach((row, index) => {
      console.log(`Processing row ${index}:`, row);
      const minInput = row.querySelector("input.channel-minutes");
      const hmsInput = row.querySelector("input.channel-hms");
      const subInput = row.querySelector("input.channel-subexp");
      const doneCell = row.querySelector("td.completed-minutes");
      const framesInput = row.querySelector("input.planned-frames-input");

      console.log(`Row ${index} elements:`, { minInput, hmsInput, subInput, doneCell, framesInput });

      const df = row.querySelector(".done-frames");
      const rf = row.querySelector(".remaining-frames");
      const rm = row.querySelector(".remaining-minutes");
      const rh = row.querySelector(".remaining-hms");
      const sb = row.querySelector(".status-badge");

      if (!minInput || !subInput || !doneCell) {
        console.log(`Row ${index} missing required elements`);
        return;
      }

      // Handle bidirectional minutes <-> H:M:S conversion for channels
      if (hmsInput) {
        const active = document.activeElement;
        
        if (active === hmsInput) {
          // User is editing HMS: update minutes
          const seconds = parseHMS(hmsInput.value);
          if (seconds !== null) {
            const convertedMinutes = seconds / 60;
            minInput.value = convertedMinutes.toFixed(1);
          }
        } else if (active === minInput || !hmsInput.value) {
          // User is editing minutes or HMS is empty: update HMS
          const inputMinutes = parseFloat(minInput.value);
          if (!isNaN(inputMinutes) && inputMinutes >= 0) {
            hmsInput.value = minutesToHMS(inputMinutes);
          }
        }
      }

      // Base values
      let mins = parseFloat(minInput.value);
      if (isNaN(mins) || mins < 0) mins = 0;

      let exp = parseFloat(subInput.value);
      if (isNaN(exp) || exp <= 0) exp = globalExp;
      if (isNaN(exp) || exp <= 0) exp = 300;  // last-resort fallback

      // Sync minutes <-> planned frames
      if (framesInput) {
        const active = document.activeElement;
        let framesVal = parseFloat(framesInput.value);

        if (active === framesInput && !isNaN(framesVal) && framesVal >= 0) {
          // User is editing frames: drive minutes from frames
          mins = (framesVal * exp) / 60.0;
          minInput.value = mins.toFixed(1);
          // Also update H:M:S field
          if (hmsInput) {
            hmsInput.value = minutesToHMS(mins);
          }
        } else {
          // User is editing minutes / subexposure / global exp:
          // recompute frames from minutes, but only if frames field is empty or this is not a custom filter with pre-set frames
          const row = framesInput.closest('tr');
          const isCustomFilter = row && row.classList.contains('custom-filter');
          const hasExistingFrames = framesInput.value && parseFloat(framesInput.value) > 0;
          
          if (mins > 0 && exp > 0 && (!isCustomFilter || !hasExistingFrames)) {
            framesVal = Math.ceil((mins * 60.0) / exp);
            framesInput.value = framesVal > 0 ? framesVal : "";
          } else if (isCustomFilter && hasExistingFrames) {
            // For custom filters with existing frames, keep the frame value as-is
            framesVal = parseFloat(framesInput.value);
          } else {
            framesVal = 0;
            framesInput.value = "";
          }
          
          // Also update H:M:S field when not the active element
          if (hmsInput && active !== hmsInput && mins >= 0) {
            hmsInput.value = minutesToHMS(mins);
          }
        }
      }

      // Remaining time
      const plannedSeconds = Math.max(mins * 60.0, 0);
      const doneSec = parseFloat(doneCell.dataset.doneSeconds || "0");
      const remainingSec = Math.max(plannedSeconds - doneSec, 0);

      rm.textContent = (remainingSec / 60).toFixed(1);
      rh.textContent = formatHMS(remainingSec);

      // Status badge
      const remMin = remainingSec / 60;
      let badge = "";

      if (remainingSec <= 0) {
        badge = '<span class="badge bg-secondary">Done</span>';
      } else if (tonightWindowMinutes <= 0) {
        badge = '<span class="badge bg-secondary">No window</span>';
      } else if (remMin <= tonightWindowMinutes * 0.8) {
        badge = '<span class="badge bg-success">Finishable tonight</span>';
      } else if (remMin <= tonightWindowMinutes * 2) {
        badge = '<span class="badge bg-warning text-dark">Good progress</span>';
      } else {
        badge = '<span class="badge bg-dark">Long-term</span>';
      }
      sb.innerHTML = badge;

      // Frame math (for done + remaining frames display)
      let plannedFrames = 0;
      let doneFrames = 0;
      let remainingFrames = 0;

      if (exp > 0) {
        plannedFrames = Math.ceil(plannedSeconds / exp);
        doneFrames = Math.floor(doneSec / exp);
        remainingFrames = Math.max(plannedFrames - doneFrames, 0);
      }

      if (df) df.textContent = doneFrames;
      if (rf) rf.textContent = remainingFrames;
    });
    
    // Update total planned time when any minutes change
    updateTotalPlannedTime();
  }

  // H:M:S parsing and formatting utilities
  function parseHMS(hmsString) {
    if (!hmsString || !hmsString.trim()) return null;
    
    const str = hmsString.trim();
    
    // Try H:M:S or H:M format
    if (str.includes(':')) {
      const parts = str.split(':').map(p => parseInt(p));
      if (parts.length === 2 && !parts.some(isNaN)) {
        return parts[0] * 3600 + parts[1] * 60; // H:M
      } else if (parts.length === 3 && !parts.some(isNaN)) {
        return parts[0] * 3600 + parts[1] * 60 + parts[2]; // H:M:S
      }
    }
    
    // Try as decimal (treat as hours if <= 24, otherwise minutes)
    const value = parseFloat(str);
    if (!isNaN(value)) {
      return value <= 24 ? value * 3600 : value * 60;
    }
    
    return null;
  }
  
  function minutesToHMS(minutes) {
    const totalSeconds = Math.max(0, Math.floor(minutes * 60));
    const h = Math.floor(totalSeconds / 3600);
    const m = Math.floor((totalSeconds % 3600) / 60);
    const s = totalSeconds % 60;
    return h + ":" + String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
  }

  // Setup bidirectional total planned time conversion
  function setupTotalTimeConversion() {
    const minutesInput = document.getElementById("total_planned_minutes");
    const hmsInput = document.getElementById("total_planned_hms");
    
    if (!minutesInput || !hmsInput) return;
    
    // Initialize HMS input with current minutes value
    if (minutesInput.value) {
      hmsInput.value = minutesToHMS(parseFloat(minutesInput.value));
    }
    
    // Minutes input changes -> update HMS
    minutesInput.addEventListener("input", function() {
      const inputMinutes = parseFloat(this.value);
      if (!isNaN(inputMinutes) && inputMinutes >= 0) {
        hmsInput.value = minutesToHMS(inputMinutes);
      }
    });
    
    // HMS input changes -> update minutes
    hmsInput.addEventListener("input", function() {
      const seconds = parseHMS(this.value);
      if (seconds !== null) {
        const convertedMinutes = seconds / 60;
        minutesInput.value = convertedMinutes.toFixed(1);
        // Trigger recalc to update the plan
        recalcFrames();
      }
    });
  }

  // Setup everything
  setupTotalTimeConversion();
  
  // Initialize channel H:M:S inputs
  rows.forEach(row => {
    const minInput = row.querySelector("input.channel-minutes");
    const hmsInput = row.querySelector("input.channel-hms");
    
    if (minInput && hmsInput && minInput.value) {
      hmsInput.value = minutesToHMS(parseFloat(minInput.value));
    }
  });


  if (globalExpInput && planTable) {
    globalExpInput.addEventListener("input", recalcFrames);
    rows.forEach(row => {
      row.querySelectorAll("input").forEach(input => {
        input.addEventListener("input", recalcFrames);
      });
    });
    recalcFrames();
  }

  setupAltitudeChart();

  function setupAltitudeChart() {
    const canvas = document.getElementById("altitudeChart");
    if (!canvas) return;

    const altitudeData = {{ window_info.altitude_profile|tojson|safe }};
    if (!altitudeData || !altitudeData.length) return;

    const minAltitude = {{ window_info.min_altitude_deg|tojson|safe }};
    const startTime = "{{ window_info.start_time_local }}".split(' ')[1].slice(0, 5); // Extract HH:MM
    const endTime = "{{ window_info.end_time_local }}".split(' ')[1].slice(0, 5); // Extract HH:MM

    const ctx = canvas.getContext("2d");
    
    // Create altitude threshold line data (horizontal line at min altitude)
    const thresholdData = altitudeData.map(() => minAltitude);
    
    // Create background color array for shading the valid window
    const backgroundColors = altitudeData.map(point => {
      const timeLabel = point.time_label;
      // Check if this time point is within the imaging window
      const isWithinWindow = timeLabel >= startTime && timeLabel <= endTime;
      return isWithinWindow ? 'rgba(76, 175, 80, 0.1)' : 'rgba(158, 158, 158, 0.1)';
    });

    altitudeChart = new Chart(ctx, {
      type: "line",
      data: {
        labels: altitudeData.map(p => p.time_label),
        datasets: [
          {
            label: "Altitude (°)",
            data: altitudeData.map(p => p.alt_deg),
            tension: 0.25,
            borderWidth: 3,
            borderColor: 'rgb(54, 162, 235)',
            backgroundColor: 'rgba(54, 162, 235, 0.1)',
            pointRadius: 0,
            fill: false
          },
          {
            label: `Min Altitude (${minAltitude}°)`,
            data: thresholdData,
            borderColor: 'rgba(244, 67, 54, 0.8)',
            backgroundColor: 'rgba(244, 67, 54, 0.1)',
            borderWidth: 2,
            borderDash: [5, 5],
            pointRadius: 0,
            fill: false
          }
        ]
      },
      options: {
        responsive: true,
        interaction: {
          intersect: false,
          mode: 'index'
        },
        plugins: {
          legend: { 
            display: true,
            position: 'top',
            labels: {
              boxWidth: 12,
              font: {
                size: 11
              },
              generateLabels: function(chart) {
                const original = Chart.defaults.plugins.legend.labels.generateLabels;
                const labels = original.call(this, chart);
                
                // Add current time indicator to legend
                labels.push({
                  text: 'Current Time',
                  fillStyle: 'rgba(255, 152, 0, 0.8)',
                  strokeStyle: 'rgba(255, 152, 0, 0.8)',
                  lineWidth: 2,
                  hidden: false,
                  pointStyle: 'line'
                });
                
                return labels;
              }
            }
          },
          tooltip: {
            callbacks: {
              afterBody: function(tooltipItems) {
                const timeLabel = tooltipItems[0].label;
                const isWithinWindow = timeLabel >= startTime && timeLabel <= endTime;
                return isWithinWindow ? 'Within imaging window' : 'Outside imaging window';
              }
            }
          }
        },
        scales: {
          y: {
            title: {
              display: true,
              text: "Altitude (°)"
            },
            suggestedMin: 0,
            suggestedMax: 90,
            grid: {
              color: function(context) {
                if (context.tick.value === minAltitude) {
                  return 'rgba(244, 67, 54, 0.3)';
                }
                return 'rgba(0, 0, 0, 0.1)';
              }
            }
          },
          x: {
            title: {
              display: true,
              text: "Local Time"
            },
            grid: {
              color: function(context) {
                const timeLabel = altitudeData[context.index]?.time_label;
                if (timeLabel) {
                  const isWithinWindow = timeLabel >= startTime && timeLabel <= endTime;
                  return isWithinWindow ? 'rgba(76, 175, 80, 0.2)' : 'rgba(158, 158, 158, 0.1)';
                }
                return 'rgba(0, 0, 0, 0.1)';
              }
            }
          }
        },
        elements: {
          point: {
            hoverRadius: 6
          }
        }
      },
      plugins: [{
        id: 'windowShading',
        beforeDatasetsDraw: function(chart) {
          const ctx = chart.ctx;
          const chartArea = chart.chartArea;
          const meta = chart.getDatasetMeta(0);
          
          if (!meta.data.length) return;
          
          // Draw background shading for the imaging window
          ctx.save();
          
          let startIndex = -1;
          let endIndex = -1;
          
          // Find the start and end indices of the imaging window
          altitudeData.forEach((point, index) => {
            const timeLabel = point.time_label;
            if (timeLabel >= startTime && startIndex === -1) {
              startIndex = index;
            }
            if (timeLabel <= endTime) {
              endIndex = index;
            }
          });
          
          if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
            const startX = meta.data[startIndex].x;
            const endX = meta.data[endIndex].x;
            
            // Draw green shading for imaging window
            ctx.fillStyle = 'rgba(76, 175, 80, 0.15)';
            ctx.fillRect(startX, chartArea.top, endX - startX, chartArea.bottom - chartArea.top);
            
            // Draw borders for the window
            ctx.strokeStyle = 'rgba(76, 175, 80, 0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(startX, chartArea.top);
            ctx.lineTo(startX, chartArea.bottom);
            ctx.moveTo(endX, chartArea.top);
            ctx.lineTo(endX, chartArea.bottom);
            ctx.stroke();
            ctx.setLineDash([]);
          }
          
          ctx.restore();
        }
      },
      {
        id: 'currentTimeLine',
        beforeDatasetsDraw: function(chart) {
          const ctx = chart.ctx;
          const chartArea = chart.chartArea;
          
          if (!chartArea) return;
          
          // Get current time in the same timezone as the chart data
          const now = new Date();
          const currentTime = now.toLocaleTimeString('en-GB', { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: false 
          });
          
          // Find the current time position on the x-axis
          const labels = chart.data.labels;
          let currentTimeX = null;
          
          // Try to find exact match first
          const exactIndex = labels.indexOf(currentTime);
          if (exactIndex !== -1) {
            const meta = chart.getDatasetMeta(0);
            if (meta.data[exactIndex]) {
              currentTimeX = meta.data[exactIndex].x;
            }
          } else {
            // If no exact match, interpolate between surrounding times
            for (let i = 0; i < labels.length - 1; i++) {
              const time1 = labels[i];
              const time2 = labels[i + 1];
              
              // Convert times to minutes for comparison
              const currentMinutes = parseInt(currentTime.split(':')[0]) * 60 + parseInt(currentTime.split(':')[1]);
              const time1Minutes = parseInt(time1.split(':')[0]) * 60 + parseInt(time1.split(':')[1]);
              const time2Minutes = parseInt(time2.split(':')[0]) * 60 + parseInt(time2.split(':')[1]);
              
              // Handle day rollover (e.g., 23:00 -> 01:00)
              const adjustedTime2Minutes = time2Minutes < time1Minutes ? time2Minutes + 1440 : time2Minutes;
              const adjustedCurrentMinutes = currentMinutes < time1Minutes ? currentMinutes + 1440 : currentMinutes;
              
              if (adjustedCurrentMinutes >= time1Minutes && adjustedCurrentMinutes <= adjustedTime2Minutes) {
                const meta = chart.getDatasetMeta(0);
                if (meta.data[i] && meta.data[i + 1]) {
                  const x1 = meta.data[i].x;
                  const x2 = meta.data[i + 1].x;
                  const ratio = (adjustedCurrentMinutes - time1Minutes) / (adjustedTime2Minutes - time1Minutes);
                  currentTimeX = x1 + (x2 - x1) * ratio;
                  break;
                }
              }
            }
          }
          
          // Draw the current time line if we found a position
          if (currentTimeX !== null && currentTimeX >= chartArea.left && currentTimeX <= chartArea.right) {
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 152, 0, 0.8)'; // Orange color
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(currentTimeX, chartArea.top);
            ctx.lineTo(currentTimeX, chartArea.bottom);
            ctx.stroke();
            
            // Add label for current time
            ctx.fillStyle = 'rgba(255, 152, 0, 1)';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Now', currentTimeX, chartArea.top - 5);
            
            ctx.restore();
          }
        }
      }]
    });
  }
  
  function updateAltitudeChart(windowInfo) {
    if (!altitudeChart || !windowInfo.altitude_profile) return;
    
    const altitudeData = windowInfo.altitude_profile;
    const minAltitude = windowInfo.min_altitude_deg;
    const startTime = windowInfo.start_time_local;
    const endTime = windowInfo.end_time_local;
    
    // Update chart data
    altitudeChart.data.labels = altitudeData.map(p => p.time_label);
    altitudeChart.data.datasets[0].data = altitudeData.map(p => p.alt_deg);
    altitudeChart.data.datasets[1].data = altitudeData.map(() => minAltitude);
    altitudeChart.data.datasets[1].label = `Min Altitude (${minAltitude}°)`;
    
    // Update background colors for window shading
    const backgroundColors = altitudeData.map(point => {
      const timeLabel = point.time_label;
      const isWithinWindow = timeLabel >= startTime && timeLabel <= endTime;
      return isWithinWindow ? 'rgba(76, 175, 80, 0.1)' : 'rgba(158, 158, 158, 0.1)';
    });
    
    // Update the chart
    altitudeChart.update('none'); // Use 'none' for immediate update without animation
  }
  
  // Function to refresh current time marker
  function refreshCurrentTimeMarker() {
    if (altitudeChart) {
      altitudeChart.update('none');
    }
  }
  
  // Update current time marker every minute
  setInterval(refreshCurrentTimeMarker, 60000);

  // Handle automatic exposure time update for progress form
  const progressChannelSelect = document.getElementById('progress_channel');
  const progressExposureInput = document.getElementById('progress_exposure');

  if (progressChannelSelect && progressExposureInput) {
    progressChannelSelect.addEventListener('change', function() {
      const selectedOption = this.options[this.selectedIndex];
      if (selectedOption && selectedOption.dataset.exposure) {
        progressExposureInput.value = selectedOption.dataset.exposure;
      }
    });
  }

  // Handle custom filter addition
  const addCustomFilterBtn = document.getElementById('add_custom_filter_btn');
  const customFiltersContainer = document.getElementById('custom_filters_container');
  const planTableBody = document.querySelector('#plan-table tbody');
  let customFilterCounter = 0;

  // Auto-calculation for custom filter form
  const customCalcInputs = document.querySelectorAll('.custom-calc-input');
  const customMinutesInput = document.getElementById('custom_channel_minutes');
  const customExposureInput = document.getElementById('custom_channel_exposure');
  const customFramesInput = document.getElementById('custom_channel_frames');
  
  // Add event listeners for auto-calculation
  customCalcInputs.forEach(input => {
    input.addEventListener('change', function() {
      calculateCustomFilterValues();
    });
  });
  
  function calculateCustomFilterValues() {
    const minutes = parseFloat(customMinutesInput.value) || 0;
    const exposure = parseFloat(customExposureInput.value) || 0;
    const frames = parseFloat(customFramesInput.value) || 0;
    
    // Count how many values are filled
    let filledCount = 0;
    if (minutes > 0) filledCount++;
    if (exposure > 0) filledCount++;
    if (frames > 0) filledCount++;
    
    // If we have exactly 2 values, calculate the third
    if (filledCount === 2) {
      if (minutes > 0 && exposure > 0 && frames === 0) {
        // Calculate frames from minutes and exposure
        const totalSeconds = minutes * 60;
        const calculatedFrames = Math.round(totalSeconds / exposure);
        customFramesInput.value = calculatedFrames;
      } else if (minutes === 0 && exposure > 0 && frames > 0) {
        // Calculate minutes from exposure and frames
        const totalSeconds = exposure * frames;
        const calculatedMinutes = (totalSeconds / 60).toFixed(1);
        customMinutesInput.value = calculatedMinutes;
      } else if (minutes > 0 && exposure === 0 && frames > 0) {
        // Calculate exposure from minutes and frames
        const totalSeconds = minutes * 60;
        const calculatedExposure = (totalSeconds / frames).toFixed(3);
        customExposureInput.value = calculatedExposure;
      }
    }
    // If all 3 values are filled (filledCount === 3), don't modify anything - user has specified all values
  }

  if (addCustomFilterBtn) {
    addCustomFilterBtn.addEventListener('click', function() {
      const name = document.getElementById('custom_channel_name').value.trim();
      const label = document.getElementById('custom_channel_label').value.trim() || name; // Use name as label if empty
      const ninaFilter = document.getElementById('custom_channel_nina_filter').value.trim();
      const customMinutes = parseFloat(customMinutesInput.value) || 0;
      const exposure = parseFloat(customExposureInput.value) || 0;
      const frames = parseFloat(customFramesInput.value) || 0;
      const weight = document.getElementById('custom_channel_weight').value;

      if (!name) {
        alert('Please enter a Channel name.');
        return;
      }
      
      if (!ninaFilter) {
        alert('Please select which standard filter this custom filter maps to for NINA export.');
        return;
      }
      
      // Validate that we have enough information to calculate
      let filledCount = 0;
      if (customMinutes > 0) filledCount++;
      if (exposure > 0) filledCount++;
      if (frames > 0) filledCount++;
      
      if (filledCount < 2) {
        alert('Please fill at least 2 of the 3 calculation fields (minutes, exposure, frames).');
        return;
      }
      
      // Do final calculation to ensure we have all 3 values
      let finalMinutes = customMinutes;
      let finalExposure = exposure;
      let finalFrames = frames;
      
      if (finalMinutes === 0) {
        finalMinutes = parseFloat(((finalExposure * finalFrames) / 60).toFixed(2));
      } else if (finalExposure === 0) {
        finalExposure = parseFloat(((finalMinutes * 60) / finalFrames).toFixed(3));
      } else if (finalFrames === 0) {
        finalFrames = Math.round((finalMinutes * 60) / finalExposure);
      }

      // Check for duplicate channel names
      const existingChannels = Array.from(planTableBody.querySelectorAll('.plan-row')).map(row => 
        row.querySelector('td:first-child').textContent.trim()
      );
      if (existingChannels.includes(name)) {
        alert(`Channel "${name}" already exists. Please use a different name.`);
        return;
      }

      // Add hidden inputs for the custom filter
      const customId = customFilterCounter++;
      customFiltersContainer.innerHTML += `
        <input type="hidden" name="custom_${customId}_name" value="${name}">
        <input type="hidden" name="custom_${customId}_label" value="${label}">
        <input type="hidden" name="custom_${customId}_nina_filter" value="${ninaFilter}">
        <input type="hidden" name="custom_${customId}_minutes" value="${finalMinutes}">
        <input type="hidden" name="custom_${customId}_exposure" value="${finalExposure}">
        <input type="hidden" name="custom_${customId}_frames" value="${finalFrames}">
        <input type="hidden" name="custom_${customId}_weight" value="${weight}">
      `;

      // Add row to the table
      const newRow = `
        <tr class="plan-row custom-filter" data-channel="${name}">
          <td>${name}</td>
          <td>${label}</td>
          <td>
            <input class="form-control form-control-sm channel-minutes minutes-input"
                  type="number" step="0.1" min="0"
                  name="ch_${name}_minutes"
                  value="${finalMinutes}"
                  title="Minutes">
          </td>
          <td>
            <input class="form-control form-control-sm channel-hms hms-input"
                  type="text" value="${Math.floor(finalMinutes / 60).toString().padStart(2, '0')}:${Math.floor(finalMinutes % 60).toString().padStart(2, '0')}:${Math.round((finalMinutes % 1) * 60).toString().padStart(2, '0')}"
                  title="H:M:S format (e.g. 3:00:00)">
          </td>
          <td>
            <input class="form-control form-control-sm channel-subexp subexp-input"
                  type="number" step="0.001" min="0.001"
                  name="ch_${name}_subexp"
                  value="${finalExposure}">
          </td>
          <td class="completed-minutes" data-done-seconds="0">0.0</td>
          <td>
            <input class="form-control form-control-sm planned-frames-input"
                  type="number" step="1" min="0" value="${finalFrames}">
          </td>
          <td class="done-frames">-</td>
          <td class="remaining-frames fw-bold">-</td>
          <td class="remaining-minutes fw-bold">-</td>
          <td class="remaining-hms fw-bold">-</td>
          <td class="status-badge"></td>
          <td>
            <button type="button" class="btn btn-sm btn-outline-danger remove-filter-btn" 
                    data-channel="${name}" title="Remove this filter">
              <i class="bi bi-trash"></i>
            </button>
          </td>
        </tr>
`;      
      planTableBody.insertAdjacentHTML('beforeend', newRow);

      // IMMEDIATE: Set the remaining calculations for the new row
      const newRowElement = planTableBody.lastElementChild;
      const remainingFramesCell = newRowElement.querySelector('.remaining-frames');
      const remainingTimeCell = newRowElement.querySelector('.remaining-minutes');
      const remainingHmsCell = newRowElement.querySelector('.remaining-hms');
      const statusCell = newRowElement.querySelector('.status-badge');
      
      // Set immediate values
      remainingFramesCell.textContent = finalFrames;
      remainingTimeCell.textContent = `${finalMinutes}`;
      const hours = Math.floor(finalMinutes / 60);
      const minutes = Math.floor(finalMinutes % 60);
      const seconds = Math.round((finalMinutes % 1) * 60);
      remainingHmsCell.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      statusCell.innerHTML = '<span class="badge bg-info">New filter</span>';

      // Clear the form
      document.getElementById('custom_channel_name').value = '';
      document.getElementById('custom_channel_label').value = '';
      document.getElementById('custom_channel_nina_filter').value = '';
      customMinutesInput.value = '';
      customExposureInput.value = '';
      customFramesInput.value = '';
      document.getElementById('custom_channel_weight').value = '1.0';

      // IMMEDIATE: Update total planned time
      const totalMinutesInput = document.getElementById('total_planned_minutes');
      if (totalMinutesInput) {
        const currentTotal = parseFloat(totalMinutesInput.value) || 0;
        totalMinutesInput.value = currentTotal + finalMinutes;
        
        // Also update H:M:S total
        const totalHmsInput = document.getElementById('total_planned_hms');
        if (totalHmsInput && typeof minutesToHMS === 'function') {
          totalHmsInput.value = minutesToHMS(currentTotal + finalMinutes);
        }
      }

      // IMPORTANT: Refresh all calculations for the new row
      setTimeout(() => {
        // Refresh progress calculations for all rows including new one
        if (typeof recalcFrames === 'function') {
          recalcFrames();
        }
        
        // Update total planned time
        if (typeof updateTotalPlannedTime === 'function') {
          updateTotalPlannedTime();
        }
        
        // Refresh the progress form filter dropdown
        if (typeof refreshProgressFilterDropdown === 'function') {
          refreshProgressFilterDropdown();
        }
        
        // Automatically save the plan after adding custom filter
        const planForm = document.getElementById('plan-form');
        if (planForm) {
          console.log('Auto-submitting plan form...');
          planForm.submit();
        } else {
          console.log('Plan form not found!');
        }
      }, 100);
    });
  }

  // Function to initialize calculations for all rows (including new ones)
  function initializeRowCalculations() {
    const newRows = document.querySelectorAll('#plan-table tbody .plan-row');
    newRows.forEach(row => {
      // Re-attach event listeners for the calculation inputs
      const minutesInput = row.querySelector('.minutes-input');
      const hmsInput = row.querySelector('.hms-input');
      const subexpInput = row.querySelector('.subexp-input');
      const framesInput = row.querySelector('.planned-frames-input');
      
      if (minutesInput && !minutesInput.hasAttribute('data-initialized')) {
        minutesInput.addEventListener('input', function() {
          recalcFrames();
        });
        minutesInput.setAttribute('data-initialized', 'true');
      }
      
      if (hmsInput && !hmsInput.hasAttribute('data-initialized')) {
        hmsInput.addEventListener('input', function() {
          recalcFrames();
        });
        hmsInput.setAttribute('data-initialized', 'true');
      }
      
      if (subexpInput && !subexpInput.hasAttribute('data-initialized')) {
        subexpInput.addEventListener('input', function() {
          recalcFrames();
        });
        subexpInput.setAttribute('data-initialized', 'true');
      }
      
      if (framesInput && !framesInput.hasAttribute('data-initialized')) {
        framesInput.addEventListener('input', function() {
          recalcFrames();
        });
        framesInput.setAttribute('data-initialized', 'true');
      }
    });
  }
  
  // Function to update total planned time
  function updateTotalPlannedTime() {
    const totalMinutesInput = document.getElementById('total_planned_minutes');
    if (!totalMinutesInput) return;
    
    let totalMinutes = 0;
    const minutesInputs = document.querySelectorAll('.minutes-input');
    minutesInputs.forEach(input => {
      const value = parseFloat(input.value) || 0;
      totalMinutes += value;
    });
    
    // Update the value without triggering events
    const currentValue = totalMinutesInput.value;
    const newValue = totalMinutes.toFixed(1);
    
    if (currentValue !== newValue) {
      totalMinutesInput.value = newValue;
      
      // Also update the H:M:S field if it exists
      const totalHmsInput = document.getElementById('total_planned_hms');
      if (totalHmsInput) {
        totalHmsInput.value = minutesToHMS(totalMinutes);
      }
    }
  }

  // Function to refresh the progress form filter dropdown  
  function refreshProgressFilterDropdown() {
    const progressChannelSelect = document.getElementById('progress_channel');
    if (!progressChannelSelect) return;
    
    // Clear existing options except the first one
    while (progressChannelSelect.children.length > 1) {
      progressChannelSelect.removeChild(progressChannelSelect.lastChild);
    }
    
    // Add all current plan filters
    const planRows = document.querySelectorAll('#plan-table tbody .plan-row');
    planRows.forEach(row => {
      const channelName = row.querySelector('td:first-child').textContent.trim();
      const channelLabel = row.querySelector('td:nth-child(2)').textContent.trim();
      const exposureInput = row.querySelector('.channel-subexp');
      const exposureValue = exposureInput ? exposureInput.value : '300';
      
      const option = document.createElement('option');
      option.value = channelName;
      option.textContent = `${channelName} - ${channelLabel}`;
      option.setAttribute('data-exposure', exposureValue);
      progressChannelSelect.appendChild(option);
    });
  }

  // Handle filter removal
  document.addEventListener('click', function(e) {
    if (e.target.closest('.remove-filter-btn')) {
      const btn = e.target.closest('.remove-filter-btn');
      const channel = btn.dataset.channel;
      const row = btn.closest('tr');
      
      if (confirm(`Remove filter "${channel}"? This action cannot be undone.`)) {
        // Add to removed filters list for all filters (including custom ones)
        const removedContainer = document.getElementById('removed_filters_container');
        removedContainer.innerHTML += `<input type="hidden" name="removed_filter" value="${channel}">`;
        
        // Remove the row
        row.remove();
        
        // Refresh progress calculations
        if (typeof recalcFrames === 'function') {
          recalcFrames();
        }
        
        // Refresh the progress form filter dropdown
        if (typeof refreshProgressFilterDropdown === 'function') {
          refreshProgressFilterDropdown();
        }
      }
    }
  });

  // Custom filter toggle functionality
  const customFilterToggleBtn = document.getElementById('customFilterToggleBtn');
  const customFilterCollapse = document.getElementById('customFilterCollapse');
  const toggleChevron = document.getElementById('toggleChevron');
  
  if (customFilterToggleBtn && customFilterCollapse) {
    customFilterToggleBtn.addEventListener('click', function() {
      if (customFilterCollapse.classList.contains('show')) {
        // Currently expanded, so collapse it
        customFilterCollapse.classList.remove('show');
        toggleChevron.classList.remove('bi-chevron-up');
        toggleChevron.classList.add('bi-chevron-down');
        customFilterToggleBtn.setAttribute('aria-expanded', 'false');
      } else {
        // Currently collapsed, so expand it
        customFilterCollapse.classList.add('show');
        toggleChevron.classList.remove('bi-chevron-down');
        toggleChevron.classList.add('bi-chevron-up');
        customFilterToggleBtn.setAttribute('aria-expanded', 'true');
      }
    });
  }
});
</script>

{% endblock %}
